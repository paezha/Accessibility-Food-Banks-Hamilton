---
title: "04-Data-Analysis"
output: html_notebook
---

Analysis of accessibility to foodbanks in Hamilton.

Load packages:
```{r load-packages, include=FALSE}
library(patchwork)
library(sf)
library(tidyverse)
#library(vaccHamilton)
```

Invoke data:
```{r}
load("output-data-files/data_da_2016.RData")
load("output-data-files/dwelling_network_points_2016.RData")
load("output-data-files/hamilton_cma.RData")
load("output-data-files/foodbank_locations.RData")
load("output-data-files/modes_less40k.RData")
load("output-data-files/ttm_car.RData")
load("output-data-files/ttm_transit.RData")
load("output-data-files/ttm_walk.RData")
#data("data_da_2016")
#data("dwelling_network_points_2016")
#data("hamilton_cma")
#data("modes_less40k")
#data("foodbank_locations")
#data("ttm_car")
#data("ttm_transit")
#data("ttm_walk")
```

## Remove entries in travel time matrices for inapplicable destinations

As a first step, we will remove the computed travel times to the three Community Kitchen locations (IDs 1-3):
```{r}
ttm_car <- ttm_car %>%
  filter(!between(OBJECTID, left = 1, right = 3))

ttm_transit <- ttm_transit %>%
  filter(!between(OBJECTID, left = 1, right = 3))

ttm_walk <- ttm_walk %>%
  filter(!between(OBJECTID, left = 1, right = 3))
```

## Quick check

Distribution of the number of foodbanks that can be reached by each mode at the maximum travel time used in the calculation of the time matrices (180 min or 10,000 m).

Car:
```{r}
ttm_car %>% group_by(UID) %>% summarize(fb_per_parcel = n()) %>% summary()
```

All parcels can reach every foodbank within 180 min.

Transit:
```{r}
ttm_transit %>% group_by(UID) %>% summarize(fb_per_parcel = n()) %>% summary()
```

Half of all parcels can reach 49 foodbanks or more in 180 min or less.

Walking:
```{r}
ttm_walk %>% group_by(UID) %>% summarize(fb_per_parcel = n()) %>% summary()
```

Half of all parcels can reach 42 foodbanks or more in 180 min or less.

## Prepare data

Join number of low income households per DA to dwellings and total number of residential units:
```{r}
dwelling_network_points_2016 <- dwelling_network_points_2016 %>%
  left_join(data_da_2016 %>%
              st_drop_geometry() %>%
              dplyr::transmute(DAUID = GeoUID, 
                               p_inc_less40k,
                               linc_age_0to2,
                               linc_age_0to19,
                               linc_age_65plus),
            by = "DAUID")
```

Calculate probability that a point on the network will have low income households. This is the proportion of low income households in the DA multiplied by the total number of residential units a the point:
```{r}
dwelling_network_points_2016 <- dwelling_network_points_2016 %>%
  mutate(income_less40k = p_inc_less40k * Dwellings)
```

Join the household data to the travel time matrices:
```{r}
ttm_car <- ttm_car %>%
  left_join(dwelling_network_points_2016 %>%
              st_drop_geometry() %>%
              dplyr::select(ID, 
                            income_less40k,
                            linc_age_0to2,
                            linc_age_0to19,
                            linc_age_65plus,
                            DAUID, 
                            TAZUID),
            by = c("UID" = "ID"))

ttm_transit <- ttm_transit %>%
  left_join(dwelling_network_points_2016 %>%
              st_drop_geometry() %>%
              dplyr::select(ID, 
                            income_less40k,
                            linc_age_0to2,
                            linc_age_0to19,
                            linc_age_65plus,
                            DAUID, 
                            TAZUID),
            by = c("UID" = "ID"))

ttm_walk <- ttm_walk %>%
  left_join(dwelling_network_points_2016 %>%
              st_drop_geometry() %>%
              dplyr::select(ID, 
                            income_less40k,
                            linc_age_0to2,
                            linc_age_0to19,
                            linc_age_65plus,
                            DAUID, 
                            TAZUID),
            by = c("UID" = "ID"))
```

Join the food bank data to the travel time matrices:
```{r}
ttm_car <- ttm_car %>%
  left_join(foodbank_locations %>%
              st_drop_geometry() %>%
              dplyr::select(ID, 
                            COVIDClose),
            by = c("OBJECTID" = "ID"))

ttm_transit <- ttm_transit %>%
  left_join(foodbank_locations %>%
              st_drop_geometry() %>%
              dplyr::select(ID, 
                            COVIDClose),
            by = c("OBJECTID" = "ID"))

ttm_walk <- ttm_walk %>%
  left_join(foodbank_locations %>%
              st_drop_geometry() %>%
              dplyr::select(ID, 
                            COVIDClose),
            by = c("OBJECTID" = "ID"))
```

Drop NAs:
```{r}
ttm_car <- ttm_car %>%
  drop_na(TAZUID,
          income_less40k)

ttm_transit <- ttm_transit %>%
  drop_na(TAZUID,
          income_less40k)

ttm_walk <- ttm_walk %>%
  drop_na(TAZUID,
          income_less40k)
```

Calculate proportion of trips by mode per TAZ:
```{r}
modes <- modes_less40k %>%
  mutate(p_car = Driver/(Driver + Transit + Walk),
         p_transit = Transit/(Driver + Transit + Walk),
         p_walk = Walk/(Driver + Transit + Walk))
```

Assume that TAZ with NAs have a proportion of car trips of one:
```{r}
modes <- modes %>%
  dplyr::mutate(p_car = replace_na(p_car, 1),
                p_transit = replace_na(p_transit, 0),
                p_walk = replace_na(p_walk, 0))
```

```{r}
# join tripmaking modal proportions
ttm_car <- ttm_car %>%
  left_join(modes %>%
              st_drop_geometry() %>%
              transmute(TAZUID,
                        p_car,
                        p_transit,
                        p_walk),
            by = "TAZUID")

ttm_transit <- ttm_transit %>%
  left_join(modes %>%
              st_drop_geometry() %>%
              transmute(TAZUID,
                        p_car,
                        p_transit,
                        p_walk),
            by = "TAZUID")

ttm_walk <- ttm_walk %>%
  left_join(modes %>%
              st_drop_geometry() %>%
              transmute(TAZUID,
                        p_car,
                        p_transit,
                        p_walk),
            by = "TAZUID")
```

Join tables:
```{r}
ttm <- ttm_car %>%
  rename(travel_time_car = travel_time) %>%
  full_join(ttm_transit %>%
              transmute(UID,
                        OBJECTID,
                        travel_time_transit = travel_time),
            by = c("UID", "OBJECTID")) %>%
  full_join(ttm_walk %>%
              transmute(UID,
                        OBJECTID,
                        travel_time_walk = travel_time),
            by = c("UID", "OBJECTID"))
```

Join proportion of trips to travel time table:
```{r}
#ttm <- ttm %>%
#  left_join(modes %>%
#              st_drop_geometry() %>%
#              transmute(TAZUID,
#                        p_car,
#                        p_transit,
#                        p_walk),
#            by = "TAZUID")
```

Check the NAs in travel time table:
```{r}
ttm %>% 
  filter(is.na(travel_time_transit)) %>%
  select(travel_time_transit,
         p_transit) %>%
  summary()
```

What does this mean? Most DAs missing travel time by transit do not report trips by transit in the TTS. In some DAs there are trips by transit (p_transit != 0), but no foodbank can be reached by transit (travel_time_transit is NA). How many of these cases?
```{r}
ttm %>% 
  filter(is.na(travel_time_transit) & p_transit > 0) %>%
  select(travel_time_transit,
         p_transit) %>%
  summary()
```

It should be fine to replace the NAs with zeros, which multiplied by p_transit will return a zero (i.e., it is not possible to reach a foodbank by transit).
```{r}
ttm <- ttm %>% 
  mutate(travel_time_transit = replace_na(travel_time_transit, 0))
```

Check the NAs in travel time by walk:
```{r}
ttm %>% 
  filter(is.na(travel_time_walk)) %>%
  select(travel_time_walk,
         p_walk) %>%
  summary()
```

What does this mean? Most DAs missing travel time by walking do not report trips by walking in the TTS. In some DAs there are trips by walking (p_walk != 0), but no foodbank can be reached by walk (travel_time_walk is NA). How many of these cases?
```{r}
ttm %>% 
  filter(is.na(travel_time_walk) & p_walk > 0) %>%
  select(travel_time_walk,
         p_walk) %>%
  summary()
```

Like with transit, it should be fine to replace the NAs with zeros, which multiplied by p_walk will return a zero (i.e., it is not possible to reach a foodbank by walking).
```{r}
ttm <- ttm %>% 
  mutate(travel_time_walk = replace_na(travel_time_walk, 0))
```

Summary of the table after these operations:
```{r}
summary(ttm)
```

Calculate expected travel times by mode. These are the travel time by the mode multiplied by the probability of using the mode (which is proxied by the proportion of trips by mode in the DA from the TTS). The total expected travel time is the sum of the expected travel times by mode:
```{r}
ttm <- ttm %>%
  mutate(e_travel_time_car = travel_time_car * p_car,
         e_travel_time_transit = travel_time_transit * p_transit,
         e_travel_time_walk = travel_time_walk * p_walk,
         e_travel_time = e_travel_time_car + e_travel_time_transit + e_travel_time_walk)
```

What is the mean expected travel time for each parcel over all the foodbanks (open and closed)?
```{r}
e_travel_time_parcel <- ttm %>% 
  group_by(UID) %>%
  summarize(DAUID = first(DAUID),
            e_travel_time = mean(e_travel_time))

summary(e_travel_time_parcel)
```

Join geometry for plotting:
```{r}
e_travel_time_parcel <- e_travel_time_parcel %>%
  left_join(dwelling_network_points_2016 %>%
              select(ID, geometry),
            by = c("UID" = "ID")) %>%
  st_as_sf()
```

Plot:
```{r}
ggplot() +
  geom_sf(data = hamilton_cma) +
  geom_sf(data = e_travel_time_parcel,
          aes(color = e_travel_time),
          alpha = 0.3) + 
  scale_color_distiller(palette = "OrRd", direction = 1)
```

What is the mean expected travel time for each parcel over all the foodbanks that did NOT close during COVID?
```{r}
e_travel_time_parcel_2 <- ttm %>% 
  filter(COVIDClose == "No") %>%
  group_by(UID) %>%
  summarize(DAUID = first(DAUID),
            e_travel_time = mean(e_travel_time))

summary(e_travel_time_parcel_2)
```

Join geometry for plotting:
```{r}
e_travel_time_parcel_2 <- e_travel_time_parcel_2 %>%
  left_join(dwelling_network_points_2016 %>%
              select(ID, geometry),
            by = c("UID" = "ID")) %>%
  st_as_sf()
```

Plot:
```{r}
ggplot() +
  geom_sf(data = hamilton_cma) +
  geom_sf(data = e_travel_time_parcel_2,
          aes(color = e_travel_time),
          alpha = 0.3) + 
  scale_color_distiller(palette = "OrRd", direction = 1)
```

Notice how expected travel time to all open food banks can _decrease_ with the closures! Food banks on average are a little bit closer, but there are _fewer_ of them, which will tend to increase the demand: 
```{r}
summary(e_travel_time_parcel)
summary(e_travel_time_parcel_2)
```

## Accessibility

Define a function for calculating accessibility using a binary impedance function:
```{r}
#' Compute balanced floating catchment area accessibility
#'
#' @param ttm A travel time matrix with a column of origin IDs, a column of destination IDs, travel times, population at the origin, and supply at the destination.
#' @param threshold A threshold for the binary impedance function
#' @return The level of service \code{los} and accessibility \code{accessibility}.
#' @export
#' @examples
#' #add(1, 1)
#' #add(10, 1)

b2sfca <- function(ttm = ttm, threshold = threshold){
  # calculate the impedance
  ttm <- ttm %>%
    dplyr::mutate(impedance_binary = ifelse(travel_time <= threshold, 1, 0))

  # Calculate the sum of the impedance by population for the balancing factors. In the binary case, this should be the same as the number of SoBi hubs that each interpolated population unit can reach
  sum_b1 <- ttm %>%
    dplyr::group_by(UID) %>%
    dplyr::summarize(sum_b1 = sum(impedance_binary),
              .groups = "drop")

  # Calculate the sum of the impedance by SoBi hubs for the balancing factors. In the binary case, this should be the same as the number of interpolated population cells that each SoBi hub serves
  sum_b2 <- ttm %>%
    dplyr::group_by(OBJECTID) %>%
    dplyr::summarize(sum_b2 = sum(impedance_binary))

  # Join the sum of the impedance to the table to calculate the balanced impedance values:
  ttm <- ttm %>%
    dplyr::left_join(sum_b1, by = "UID") %>%
    dplyr::left_join(sum_b2, by = "OBJECTID")

  # **Important:** notice that some values of `sum_b1` are zeros! This means that some population units cannot reach a SoBi hub in at most 24 min. Since the balancing impedance is calculated by diving the impedance by `sum_b1`, this will lead to NaNs (divisions by zero). To avoid issues we will remove any population units that reach zero hubs:
  ttm <- ttm %>%
    dplyr::filter(sum_b1 > 0,
                  sum_b2 > 0)

  # Calculate balanced impedance values:
  ttm <- ttm %>%
    dplyr::mutate(balanced_impedance_1 = impedance_binary/sum_b1,
                  balanced_impedance_2 = impedance_binary/sum_b2)

  # The level of service of each hub is the number of bicycle racks at the hub, divided by the population that they serve:
  los <- ttm %>%
    dplyr::group_by(OBJECTID) %>%
    dplyr::summarize(los = dplyr::first(supply) / sum((population * balanced_impedance_1)),
              .groups = "drop")

  # Join the level of service to the table:
  ttm <- ttm %>%
    dplyr::left_join(los, by = "OBJECTID")

  # To calculate accessibility, the level of service of each hub needs to be distributed proportionally to the population units.
  accessibility <- ttm %>%
    dplyr::group_by(UID) %>%
    dplyr::summarize(accessibility = sum(los * balanced_impedance_2),
              .groups = "drop")

  output = list(los = los,
                accessibility = accessibility)
  return(output)
}
```

Calculate accessibility with a threshold of 15 min:
```{r}
acc_15min <- ttm %>% 
  transmute(UID, OBJECTID, travel_time = e_travel_time, population = income_less40k, supply = 1) %>%
  b2sfca(threshold = 15)
```

Check that los and accessibility balance:
```{r}
sum(acc_15min$los$los)
sum(acc_15min$accessibility$accessibility)
```

Sensitivity analysis:
```{r accessibility-sensibility}
# Testing different thresholds to check how accessibility changes
threshold_seq <- seq(from = 2, to = 30, by = 2)

accessibility_test <- data.frame(threshold = threshold_seq, 
                                 accessibility = numeric(length(threshold_seq)))
for(i in 1:length(threshold_seq)){
  results_test <-  ttm %>% 
  transmute(UID, OBJECTID, travel_time = e_travel_time, population = income_less40k, supply = 1) %>%
    b2sfca(threshold = i )
  accessibility_test$accessibility[i] <- sum(results_test$accessibility$accessibility)
}

ggplot(accessibility_test, 
       aes(x = threshold, y = accessibility)) +
  geom_line()
```

30-min accessibility pre-covid:
```{r 30-min-pre-covid, include=FALSE}
results_30min_pre <- ttm %>%
  #dplyr::filter(COVIDClose == "No") %>%
  transmute(UID, 
            OBJECTID, 
            travel_time = e_travel_time, 
            population = income_less40k, 
            supply = 1) %>%
  b2sfca(threshold = 30)
```

30-min accessibility during covid:
```{r 30-min-during-covid, include=FALSE}
results_30min_covid <- ttm %>%
  dplyr::filter(COVIDClose == "No") %>%
  transmute(UID, 
            OBJECTID, 
            travel_time = e_travel_time, 
            population = income_less40k, 
            supply = 1) %>%
  b2sfca(threshold = 30)
```

Regional accessibility pre-covid:
```{r, 30-min-sum-pre}
sum(results_30min_pre$los$los)
sum(results_30min_pre$accessibility$accessibility)
```

Regional accessibility during covid:
```{r 30-min-sum-covid}
sum(results_30min_covid$los$los)
sum(results_30min_covid$accessibility$accessibility)
```

Bind results:
```{r, bind-all-results}
los <- rbind(data.frame(results_30min_pre$los, 
                        timing = "Pre-covid", 
                        threshold = "30 min"),
             data.frame(results_30min_covid$los, 
                        timing = "During covid", 
                        threshold = "30 min")) %>%
  mutate(timing = factor(timing, 
                         levels = c("Pre-covid", 
                                    "During covid"),
                         ordered = TRUE))

accessibility <- rbind(data.frame(results_30min_pre$accessibility, 
                                  timing = "Pre-covid", 
                                  threshold = "30 min"),
                       data.frame(results_30min_covid$accessibility, 
                                  timing = "During covid", 
                                  threshold = "30 min")) %>%
  mutate(timing = factor(timing, 
                         levels = c("Pre-covid", 
                                    "During covid"),
                         ordered = TRUE))
```

Join geometry:
```{r, add-geometry-to-results, include=FALSE}
los <- los %>%
  left_join(foodbank_locations %>%
              dplyr::select(ID),
            by = c("OBJECTID" = "ID")) %>%
  st_as_sf()

accessibility <- accessibility %>%
  left_join(dwelling_network_points_2016 %>%
              dplyr::select(ID),
            by = c("UID" = "ID")) %>%
  st_as_sf()
```

Plot levels of service before and during covid:
```{r}
los_pre <- ggplot() +
  geom_sf(data = hamilton_cma) +
  geom_sf(data = los %>%
            filter(timing == "Pre-covid"),
          aes(color = los,
              size = los)) +
  geom_sf(data = foodbank_locations,
          aes(shape = COVIDClose)) +
  scale_color_distiller(palette = "OrRd", 
                        direction = 1) +
  scale_shape_manual(values = c("Yes" = 4, "No" = 1))

los_covid <- ggplot() +
  geom_sf(data = hamilton_cma) +
  geom_sf(data = los %>%
            filter(timing == "During covid"),
          aes(color = los,
              size = los)) +
  geom_sf(data = foodbank_locations,
          aes(shape = COVIDClose)) +
  scale_color_distiller(palette = "OrRd", 
                        direction = 1) +
  scale_shape_manual(values = c("Yes" = 4, "No" = 1))

los_pre / los_covid
```

Plot the change in level of service:
```{r}
los %>%
  st_drop_geometry() %>%
  pivot_wider(names_from = timing, 
              values_from = los, 
              values_fill = 0) %>%
  filter(`During covid` > 0) %>%
  mutate(los_d = `During covid` / `Pre-covid` - 1) %>%
  left_join(foodbank_locations %>%
            transmute(OBJECTID = ID,
                      geometry),
          by = "OBJECTID") %>%
  st_as_sf() %>%
  ggplot() +
  geom_sf(data = hamilton_cma) +
  geom_sf(aes(color = los_d,
              size = los_d)) +
  geom_sf(data = foodbank_locations,
          aes(shape = COVIDClose)) +
  scale_color_distiller(palette = "OrRd", 
                        direction = -1) +
  scale_shape_manual(values = c("Yes" = 4, "No" = 1))
  
```

Here we can see the places where the level of service deteriorated most (excluding the places that closed, where it vanished).

Plot accessibility before and during covid:
```{r}
acc_pre <- ggplot() +
  geom_sf(data = hamilton_cma) +
  geom_sf(data = accessibility %>%
            filter(timing == "Pre-covid"),
          aes(color = accessibility)) +
  scale_color_distiller(palette = "OrRd", 
                        direction = 1)

acc_covid <- ggplot() +
  geom_sf(data = hamilton_cma) +
  geom_sf(data = accessibility %>%
            filter(timing == "During covid"),
          aes(color = accessibility)) +
  scale_color_distiller(palette = "OrRd", 
                        direction = 1)

acc_pre / acc_covid
```

Plot the change in accessibility by DA:
```{r}
accessibility %>%
  st_drop_geometry() %>%
  # Copy the DA identifier to the accessibility table
  left_join(dwelling_network_points_2016 %>%
              st_drop_geometry() %>%
              transmute(UID = ID, DAUID),
            by = "UID") %>%
  # Group by DA and time
  group_by(DAUID, timing) %>%
  # Calculate the accessibility by DA before and during covid
  summarize(accessibility = sum(accessibility),
            timing = first(timing),
            .groups = "drop") %>%
  # Pivot wider to calculate the differences in accessibility from pre-covid to covid
  pivot_wider(names_from = timing, 
              values_from = accessibility) %>%
  # Calculate changes in accessibility
  mutate(acc_d = `During covid` / `Pre-covid` - 1) %>%
  # Join DA geometry
  left_join(data_da_2016 %>%
            transmute(DAUID = GeoUID,
                      geometry),
          by = "DAUID") %>%
  # Convert to simple features
  st_as_sf() %>%
  # Plot
  ggplot() +
  geom_sf(data = hamilton_cma) +
  geom_sf(aes(fill = acc_d),
          color = NA) +
  scale_fill_distiller(palette = "OrRd", 
                        direction = -1)
  
```

```{r}
access_by_da <- accessibility %>%
  st_drop_geometry() %>%
  # Copy the DA identifier to the accessibility table
  left_join(dwelling_network_points_2016 %>%
              st_drop_geometry() %>%
              transmute(UID = ID, DAUID),
            by = "UID") %>%
  # Group by DA and time
  group_by(DAUID, timing) %>%
  # Calculate the accessibility by DA before and during covid
  summarize(accessibility = sum(accessibility),
            timing = first(timing),
            .groups = "drop") %>%
  # Pivot wider to calculate the differences in accessibility from pre-covid to covid
  pivot_wider(names_from = timing, 
              values_from = accessibility) %>%
  # Calculate changes in accessibility
  mutate(acc_d = `During covid` / `Pre-covid` - 1) %>%
  # Join DA geometry
  left_join(data_da_2016 %>%
            transmute(DAUID = GeoUID,
                      geometry),
          by = "DAUID") %>%
  # Convert to simple features
  st_as_sf() 
tmap_mode("view")
tm_shape(access_by_da) + 
  tm_fill("acc_d")
```



## Further Breakdown by Population Characteristics

### CODE TO BE UPDATED
Get minimum travel times in the pre-covid scenario:

```{r minimum-travel-time-baseline, include=FALSE}
# retrieve minimum travel time during covid to sites that didnt close
min_ttm_car_baseline <- ttm_car %>%
  #dplyr::filter(COVIDClose == "No") %>%
  group_by(UID) %>%
  summarize(travel_time = min(travel_time),
            linc_age_0to2 = first(linc_age_0to2),
            linc_age_0to19 = first(linc_age_0to19),
            linc_age_65plus = first(linc_age_0to19),
            DAUID = first(DAUID),
            TAZUID = first(TAZUID),
            p_car = first(p_car),
            p_transit = first(p_transit),
            p_walk = first(p_walk),
            .groups = "drop") %>%
  
  ## Calculate weighted travel time:
  mutate(weighted_travel_time = travel_time * p_car)

min_ttm_transit_baseline <- ttm_transit %>%
  #dplyr::filter(COVIDClose == "No") %>%
  group_by(UID) %>%
  summarize(travel_time = min(travel_time),
            linc_age_0to2 = first(linc_age_0to2),
            linc_age_0to19 = first(linc_age_0to19),
            linc_age_65plus = first(linc_age_0to19),
            DAUID = first(DAUID),
            TAZUID = first(TAZUID),
            p_car = first(p_car),
            p_transit = first(p_transit),
            p_walk = first(p_walk),
            .groups = "drop") %>%
  
  ## Calculate weighted travel time:
  mutate(weighted_travel_time = travel_time * p_transit)

min_ttm_walk_baseline <- ttm_walk %>%
  #dplyr::filter(COVIDClose == "No") %>%
  group_by(UID) %>%
  summarize(travel_time = min(travel_time),
            linc_age_0to2 = first(linc_age_0to2),
            linc_age_0to19 = first(linc_age_0to19),
            linc_age_65plus = first(linc_age_0to19),
            DAUID = first(DAUID),
            TAZUID = first(TAZUID),
            p_car = first(p_car),
            p_transit = first(p_transit),
            p_walk = first(p_walk),
            .groups = "drop") %>%
  
  ## Calculate weighted travel time:
  mutate(weighted_travel_time = travel_time * p_walk)
```

```{r weighted-travel-time-by-mode-baseline, include=FALSE}
# Baseline analysis (pre-COVID)
## Bind the three tables and label them by mode:
min_ttm_mode_baseline <- rbind(data.frame(min_ttm_car_baseline, Mode = "Car"),
                               data.frame(min_ttm_transit_baseline, Mode = "Transit"),
                               data.frame(min_ttm_walk_baseline, Mode = "Walking"))
```

```{r aggregate-weighted-travel-times-baseline, include=FALSE}
# Baseline analysis (PILOT LOCATIONS ONLY)
## Aggregate weighted travel times by mode:
min_ttm_baseline <- min_ttm_mode_baseline %>%
  group_by(UID) %>%
  summarize(DAUID = first(DAUID),
            TAZUID = first(TAZUID),
            linc_age_0to2 = first(linc_age_0to2),
            linc_age_0to19 = first(linc_age_0to19),
            linc_age_65plus = first(linc_age_0to19),
            weighted_travel_time = sum(weighted_travel_time)) %>%
  
  ## Calculate person-hours of travel:
  mutate(weighted_person_hours_0to2 = linc_age_0to2 * weighted_travel_time/60)
```


```{r summarize-results-by-taz-baseline, include=FALSE}
# Baseline analysis (PILOT LOCATIONS ONLY)
## Summarize by TAZ and join geometry:
min_ttm_baseline_taz <- min_ttm_baseline %>%
  group_by(TAZUID) %>%
  summarize(weighted_travel_time = mean(weighted_travel_time),
            weighted_person_hours_0to2 = sum(weighted_person_hours_0to2)) %>%
  left_join(modes %>%
              dplyr::select(TAZUID),
            by = "TAZUID") %>%
  st_as_sf()
```

```{r weighted-travel-time-map-baseline}
ttm_map_baseline <- ggplot() +
  geom_sf(data = min_ttm_baseline_taz,
          aes(fill = weighted_travel_time),
          color = NA) +
  scale_fill_distiller(name = "Expected travel time (min)",
                       palette = "OrRd", 
                       direction = 1) +
  theme_minimal() +
  theme(panel.grid = element_blank(),
        axis.text = element_text(size = 7),
        legend.position = "bottom",
        legend.text = element_text(size = 8))

ttm_map_baseline
```


```{r}
tmap_mode("view")
tm_shape(min_ttm_baseline_taz) +
  tm_fill(col = "weighted_travel_time")

tm_shape(modes) +
  tm_fill(col = "p_walk")
```


```{r person-hours-traveled-map-baseline}
# Baseline analysis (PILOT LOCATIONS ONLY)
## Map weighted person-hours of travel:
pht_map_baseline <- ggplot() +
  geom_sf(data = min_ttm_baseline_taz,
          aes(fill = weighted_person_hours_0to2),
          color = NA) +
  scale_fill_distiller(name = "Person-hours of travel",
                       palette = "OrRd", 
                       direction = 1) +
  #geom_sf(data = urban_types,
  #        aes(color = Type),
  #        fill = NA) +
  #scale_color_manual(name = "",
  #                   values = c("Urban" = "firebrick2",
  #                              "Suburban" = "cornflowerblue",
  #                              "Rural" = "forestgreen"))  +
  theme_minimal() +
  theme(panel.grid = element_blank(),
        axis.text = element_text(size = 7),
        legend.position = "bottom",
        legend.text = element_text(size = 8))

pht_map_baseline
```

```{r join-income-information-baseline, include=FALSE}
# Baseline analysis (PILOT LOCATIONS ONLY)
## Join median household information to table:
min_ttm_baseline <- min_ttm_baseline %>%
  left_join(data_da_2016 %>%
              st_drop_geometry() %>%
              dplyr::transmute(DAUID = GeoUID,
                               income_quintile),
            by = "DAUID")
```

```{r plot-distribution-travel-time-by-income-baseline}
# Baseline analysis (PILOT LOCATIONS ONLY)
## Distribution of weighted travel time by income:
ttm_income_baseline <- ggplot(data = min_ttm_baseline, 
       aes(x = weighted_travel_time, 
           color= income_quintile)) +
  geom_density(size = 0.5, adjust = 2.5) +
  labs(x = "Travel time (in minutes; weighted by mode)") +
  scale_color_manual(values = c("Top 20%" = "blue",
                                "Second 20%" = "steelblue1",
                                "Third 20%" = "gray40", 
                                "Fourth 20%" = "tomato",
                                "Bottom 20%" = "red")) +
  theme_minimal() +
  theme(text = element_text(size = 7),
        legend.text = element_text(size = 7))

ttm_income_baseline
```

```{r total-weighted-person-hours-by-group-baseline, include=FALSE}
# Baseline analysis (PILOT LOCATIONS ONLY)
## Total weighted person-hours by income:
person_hours_income_baseline <- min_ttm_baseline %>%
  group_by(income_quintile) %>%
  summarize(total_weighted_person_hours = sum(weighted_person_hours),
            total_population = sum(Population),
            .groups = "drop") %>%
  mutate(ratio = total_weighted_person_hours/total_population) %>%
  rename(group = income_quintile)

## Total weighted person-hours by region:
person_hours_region_baseline <- min_ttm %>%
  group_by(Urban_type) %>%
  summarize(total_weighted_person_hours = sum(weighted_person_hours),
            total_population = sum(Population),
            .groups = "drop") %>%
  drop_na() %>%
  mutate(ratio = total_weighted_person_hours/total_population) %>%
  rename(group = Urban_type)

person_hours_baseline <- rbind(person_hours_income_baseline,
                               person_hours_region_baseline)
```





### Do Again for COVID Scenario
Get minimum travel times in the during covid scenario:

```{r minimum-travel-time-during-covid, include=FALSE}
# retrieve minimum travel time during covid to sites that didnt close
min_ttm_car_during <- ttm_car %>%
  dplyr::filter(COVIDClose == "No") %>%
  group_by(UID) %>%
  summarize(travel_time = min(travel_time),
            linc_age_0to2 = first(linc_age_0to2),
            linc_age_0to19 = first(linc_age_0to19),
            linc_age_65plus = first(linc_age_0to19),
            DAUID = first(DAUID),
            TAZUID = first(TAZUID),
            p_car = first(p_car),
            p_transit = first(p_transit),
            p_walk = first(p_walk),
            .groups = "drop")

min_ttm_transit_during <- ttm_transit %>%
  dplyr::filter(COVIDClose == "No") %>%
  group_by(UID) %>%
  summarize(travel_time = min(travel_time),
            linc_age_0to2 = first(linc_age_0to2),
            linc_age_0to19 = first(linc_age_0to19),
            linc_age_65plus = first(linc_age_0to19),
            DAUID = first(DAUID),
            TAZUID = first(TAZUID),
            p_car = first(p_car),
            p_transit = first(p_transit),
            p_walk = first(p_walk),
            .groups = "drop")

min_ttm_walk_during <- ttm_walk %>%
  dplyr::filter(COVIDClose == "No") %>%
  group_by(UID) %>%
  summarize(travel_time = min(travel_time),
            linc_age_0to2 = first(linc_age_0to2),
            linc_age_0to19 = first(linc_age_0to19),
            linc_age_65plus = first(linc_age_0to19),
            DAUID = first(DAUID),
            TAZUID = first(TAZUID),
            p_car = first(p_car),
            p_transit = first(p_transit),
            p_walk = first(p_walk),
            .groups = "drop")
```



```{r}
# FULL JOIN THEM TOGETHER
```

## Exploratory data analysis

Summary of population:
```{r}
sum(data_da_2016$Population_55to69, na.rm = TRUE)
sum(data_da_2016$Population_70plus, na.rm = TRUE)
```

Check the total population:
```{r}
sum(dwelling_network_points_2016$Population_55to69, na.rm = TRUE)
sum(dwelling_network_points_2016$Population_70plus, na.rm = TRUE)
```

The difference in population is because the residential units considered do not completely cover the Hamilton CMA:
```{r}
ggplot() +
geom_sf(data = hamilton_cma) + 
geom_sf(data = dwelling_network_points_2016) + 
geom_sf(data = pharmacy_locations, 
aes(color = Type,
shape = Type), 
size = 3)
```

Plot population age 55 to 69:
```{r}
ggplot() +
geom_sf(data = data_da_2016 %>%
filter(`Region Name` == "Hamilton"),
aes(fill = Population_55to69),
color = NA) +
geom_sf(data = hamilton_cma,
fill = NA) +
scale_fill_distiller(palette = "OrRd", 
direction = 1)
```

Plot population age 70 plus:
```{r}
ggplot() +
geom_sf(data = data_da_2016 %>%
filter(`Region Name` == "Hamilton"),
aes(fill = Population_70plus),
color = NA) +
geom_sf(data = hamilton_cma,
fill = NA) +
scale_fill_distiller(palette = "OrRd", 
direction = 1)
```
